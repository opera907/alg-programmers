## 케이스 주제
[완전탐색] 모의고사

https://programmers.co.kr/learn/courses/30/lessons/42840?language=javascript#

## 기능 요구사항

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한 조건
1. 시험은 최대 10,000 문제로 구성되어있습니다.
2. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
3. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

## 기능 작동 완성

[내 로직]
1. 1번 수포자와 답 비교 , 2번과 답 비교, 3번과 답비교
2. answers 일치하는 값 -> 결과값으로 받음 
3. answers과 가장 많이 일치하는 수포자의 답 -> 결과값에서 가장 긴배열 찾기
4. 3을 배열에


## 문제

1. 테스트 케이스 절반이 실패였음 . 효율성 40점쯤 

? 배열의 복제
어차피 찍는 방식은 같고, 최대 1000까지 그 방식이 반복되어야 했음
이걸,, concat이나 펼침연산자로 반복해야하나,, 고민했음

일단 무시하고 문제 푼 게 화근

answer이 최대 1000인텐데 mine배열은 짧았음
그래서 for문에서 mine배열 이상의 순서가 올때, 값이 오류가 남

--> 증가하는 인덱스를 자신배열의 길이로 나눌때 나머지 값을 이용한다 
--> 슬라이드에서도 사용가능하겠다. 


(X) answer[i] === mine[i]
(O) answer[i] === mine[i % mine.length]

## 주요 학습 키워드

[처음 써봄]
1. Math.max()
2. mine[i % mine.length]

1. 두 배열의 값 비교


## 개선할 점

1 for문 없애기
2 일치값 받는 부분 
-> 함수를 3번 실행하면서 값을 받아오고 있음
2 ss 함수 없애기 
3 최대값 비교 부분 
-> 코드가 반복됨 
